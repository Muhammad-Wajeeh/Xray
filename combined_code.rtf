{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica-Light;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\pardirnatural\partightenfactor0

\f0\fs24 \cf0 ## README\
\
## Code Execution Instructions\
\
### Environment\
- Python 3.10+ recommended.\
- Create and activate a virtual environment:\
  ```\
  python -m venv .venv\
  source .venv/bin/activate   # on Windows: .venv\\Scripts\\activate\
  ```\
\
### Install prerequisites\
- From the repo root (`Xray/`), install required packages:\
  ```\
  pip install -r requirements.txt\
  ```\
Packages used: numpy, matplotlib, scikit-image, PyQt5.\
\
### Datasets / external resources\
- None required. All phantoms are generated procedurally; no downloads needed.\
\
### Run the GUI (generate interactive results)\
```\
python gui.py\
```\
Suggested starting sliders: angle 0\'9610\'b0, SID 500, SDD 1000, kVp 30\'9640, exposure x0.01s 80\'96120, filtration 2\'963 mm Al, grid off for brightness. Compression toggle compares thickness. The GUI shows the radiograph/sinogram and profile overlays; ROI stats/contrast are displayed in the sidebar.\
\
### Regenerate figures (non-interactive)\
```\
python generate_figures.py\
```\
Outputs saved under `figs/` and prints ROI/contrast stats for baseline and compressed phantoms. No training/testing steps apply (not an AI model).\
\
## Generated figures (in `figs/`)\
- `baseline_radiograph.png`: baseline breast radiograph (0\'b0, SID 500/SDD 1000, kVp 35, exposure 1s, 2mm Al).\
- `distance_variation.png`: baseline vs closer (SID 350) vs farther (SID 700) showing magnification/edge shifts.\
- `mu_variation.png`: baseline vs denser (higher \uc0\u956 ) material.\
- `angle_variation.png`: radiographs at 0/15/30 degrees.\
- `profile_overlays.png`: baseline profile with overlays for distance, \uc0\u956 , angle.\
- `profile_compressed.png`: baseline vs compressed breast profile.\
- `sinogram.png`: 0\'96180\'b0 sinogram.\
- `phantom_schematic.png`: \uc0\u956  map schematic with skin rim, pectoral wedge, gland core, lesion, calc spots.\
\
## How this maps to the project proposal\
- GUI controls for beam energy (kVp), SID/SDD, angle, exposure, filtration, grid: **present** (`gui.py`).\
- Breast phantom with lesion, calc spots, benign mass, compression toggle: **present** (`phantom.py`, used in GUI and figures).\
- 2D radiograph and sinogram views: **present** (`gui.py`, `simulate_xray.py`).\
- Intensity profiles baseline + distance/\uc0\u956 /angle overlays with notes: **present** (`gui.py` bottom plot, `figs/profile_overlays.png`).\
- Compressed vs baseline comparison: **present** (GUI compression toggle; `figs/profile_compressed.png`).\
- ROI stats/contrast for lesion vs background: **present** (GUI sidebar text; printed in `generate_figures.py` output).\
- Schematic/diagram with attenuation labels: **present** (`figs/phantom_schematic.png`).\
- Saved figures for baseline and parameter variations: **present** (`figs/`).\
- Baseline 2D projection of \'933D phantom\'94: **not implemented** (we use 2D phantom); can add a simple 3D-to-2D projection if required.\
- Quantitative tables for parameter variations: basic ROI/contrast numbers printed by `generate_figures.py`; extend to CSV if needed.\
\
\
\
\
## gui.py\
\
import sys\
import numpy as np\
from PyQt5.QtWidgets import (\
    QApplication, QMainWindow, QWidget,\
    QVBoxLayout, QHBoxLayout, QLabel, QSlider,\
    QComboBox, QCheckBox\
)\
from PyQt5.QtCore import Qt\
\
from matplotlib.backends.backend_qt5agg import FigureCanvasQTAgg as FigureCanvas\
from matplotlib.figure import Figure\
\
from ProjectFunctions.phantom import create_shepp_logan, create_breast_phantom\
from ProjectFunctions.simulate_xray import (\
    simulate_sinogram,\
    simulate_projection_single,\
    simulate_projection,\
    simulate_projection_angle,\
    simulate_xray_2d,\
)\
from ProjectFunctions.utils import roi_mean_std, roi_contrast\
\
\
class XrayGUI(QMainWindow):\
    def __init__(self):\
        """Initialize GUI, load phantoms, build layout, and draw first view."""\
        super().__init__()\
        self.setWindowTitle("X-ray Simulation GUI")\
\
        self.phantom = create_shepp_logan()\
        self.breast_base, self.breast_info = create_breast_phantom()\
        self.breast_compressed, self.breast_info_compressed = create_breast_phantom(\
            compression=True\
        )\
        self.fig = Figure(figsize=(8, 8))\
        self.canvas = FigureCanvas(self.fig)\
        self.ax_img, self.ax_profile = self.fig.subplots(2, 1)\
\
        self.angle_slider = self.create_slider(0, 180, 30, "Angle (deg)")\
        self.sid_slider   = self.create_slider(200, 1200, 500, "SID")\
        self.sdd_slider   = self.create_slider(400, 1600, 1000, "SDD")\
        self.kvp_slider   = self.create_slider(20, 120, 30, "kVp")\
        self.exp_slider   = self.create_slider(1, 300, 100, "Exposure x0.01 s")\
        self.filt_slider  = self.create_slider(0, 10, 2, "Filtration (mm Al)")\
\
        self.view_selector = QComboBox()\
        self.view_selector.addItems(["X-ray Projection", "Sinogram"])\
        self.view_selector.currentIndexChanged.connect(self.update_projection)\
\
        self.breast_toggle = QCheckBox("Use breast phantom")\
        self.breast_toggle.setChecked(True)\
        self.compress_toggle = QCheckBox("Compression (thinner breast)")\
        self.grid_toggle = QCheckBox("Anti-scatter grid")\
        for cb in [self.breast_toggle, self.compress_toggle, self.grid_toggle]:\
            cb.stateChanged.connect(self.update_projection)\
        self.phantom_info = QLabel("Phantom \uc0\u956 : adipose 0.22, gland 0.40, lesion 0.75")\
        self.roi_stats = QLabel("ROI stats: N/A")\
\
        sliders = QVBoxLayout()\
\
        for label, slider in [\
            self.angle_slider,\
            self.sid_slider,\
            self.sdd_slider,\
            self.kvp_slider,\
            self.exp_slider,\
            self.filt_slider,\
        ]:\
            row = QHBoxLayout()\
            row.addWidget(label)\
            row.addWidget(slider)\
            sliders.addLayout(row)\
\
        sliders.addWidget(QLabel("View Mode:"))\
        sliders.addWidget(self.view_selector)\
        sliders.addWidget(self.breast_toggle)\
        sliders.addWidget(self.compress_toggle)\
        sliders.addWidget(self.grid_toggle)\
        sliders.addWidget(self.phantom_info)\
        sliders.addWidget(self.roi_stats)\
\
        slider_panel = QWidget()\
        slider_panel.setLayout(sliders)\
\
        main_layout = QHBoxLayout()\
        main_layout.addWidget(self.canvas, stretch=3)\
        main_layout.addWidget(slider_panel, stretch=1)\
\
        container = QWidget()\
        container.setLayout(main_layout)\
        self.setCentralWidget(container)\
\
        for _, slider in [\
            self.angle_slider,\
            self.sid_slider,\
            self.sdd_slider,\
            self.kvp_slider,\
            self.exp_slider,\
            self.filt_slider,\
        ]:\
            slider.valueChanged.connect(self.update_projection)\
\
        self.update_projection()\
\
    def create_slider(self, min_val, max_val, init, label_text):\
        """Create horizontal slider with label; returns (label, slider)."""\
        label = QLabel(f"\{label_text\}: \{init\}")\
        slider = QSlider(Qt.Horizontal)\
        slider.setMinimum(min_val)\
        slider.setMaximum(max_val)\
        slider.setValue(init)\
        slider.label_text = label_text\
        return label, slider\
\
    def update_projection(self):\
        """Recompute image, profiles, ROI stats using current slider/toggle settings."""\
        angle = self.angle_slider[1].value()\
        sid   = self.sid_slider[1].value()\
        sdd   = self.sdd_slider[1].value()\
        kvp   = self.kvp_slider[1].value()\
        exposure = self.exp_slider[1].value() / 100.0\
        filt  = self.filt_slider[1].value()\
        grid_ratio = 0.75 if self.grid_toggle.isChecked() else 1.0\
\
        use_breast = self.breast_toggle.isChecked()\
        use_compression = self.compress_toggle.isChecked() if use_breast else False\
        if use_breast:\
            phantom = self.breast_compressed if use_compression else self.breast_base\
            phantom_info = self.breast_info_compressed if use_compression else self.breast_info\
        else:\
            phantom = self.phantom\
            phantom_info = None\
        use_external = False\
\
        self.angle_slider[0].setText(f"Angle: \{angle\}\'b0")\
        self.sid_slider[0].setText(f"SID: \{sid\}")\
        self.sdd_slider[0].setText(f"SDD: \{sdd\}")\
        self.kvp_slider[0].setText(f"kVp: \{kvp\}")\
        self.exp_slider[0].setText(f"Exposure x0.01s: \{self.exp_slider[1].value()\}")\
        self.filt_slider[0].setText(f"Filtration (mm AL): \{filt\}")\
\
        mode = self.view_selector.currentText()\
\
        if mode == "X-ray Projection":\
            img = simulate_xray_2d(\
                phantom,\
                angle,\
                I0=1.0,\
                sid=sid,\
                sdd=sdd,\
                kVp=kvp,\
                exposure_time=exposure,\
                filtration_mmAl=filt,\
                grid_ratio=grid_ratio,\
            )\
            title = f"X-ray Projection @ \{angle\}\'b0"\
\
        else:\
            img, _ = simulate_sinogram(\
                phantom, angle, sid, sdd, kvp, exposure, filt, grid_ratio=grid_ratio\
            )\
            title = f"Sinogram (0 \uc0\u8594  \{angle\}\'b0)"\
\
        if not hasattr(self, "im"):\
            self.ax_img.clear()\
            self.im = self.ax_img.imshow(\
                img, cmap="gray", vmin=0.0, vmax=0.7, aspect="auto"\
            )\
        else:\
            self.im.set_data(img)\
            self.im.set_clim(0.0, 0.7)\
\
        self.ax_img.set_title(title)\
\
        baseline = simulate_projection(\
            phantom,\
            I0=1.0,\
            sid=sid,\
            sdd=sdd,\
            kVp=kvp,\
            exposure_time=exposure,\
            filtration_mmAl=filt,\
            grid_ratio=grid_ratio,\
        )\
\
        x = np.arange(baseline.size)\
        need_reset_profiles = (\
            not hasattr(self, "profile_lines")\
            or len(self.profile_lines[0].get_xdata()) != baseline.size\
        )\
\
        closer_sid = max(100, int(sid * 0.7))\
        dist_var = simulate_projection(\
            phantom,\
            I0=1.0,\
            sid=closer_sid,\
            sdd=sdd,\
            kVp=kvp,\
            exposure_time=exposure,\
            filtration_mmAl=filt,\
            grid_ratio=grid_ratio,\
        )\
\
        dense_phantom = phantom * 1.25\
        att_var = simulate_projection(\
            dense_phantom,\
            I0=1.0,\
            sid=sid,\
            sdd=sdd,\
            kVp=kvp,\
            exposure_time=exposure,\
            filtration_mmAl=filt,\
            grid_ratio=grid_ratio,\
        )\
\
        angle_var_deg = max(5, int(angle))\
        angle_var, _ = simulate_projection_angle(\
            phantom,\
            angle_var_deg,\
            I0=1.0,\
            sid=sid,\
            sdd=sdd,\
            kVp=kvp,\
            exposure_time=exposure,\
            filtration_mmAl=filt,\
            grid_ratio=grid_ratio,\
        )\
\
        if use_breast:\
            base_profile = simulate_projection(\
                self.breast_base,\
                I0=1.0,\
                sid=sid,\
                sdd=sdd,\
                kVp=kvp,\
                exposure_time=exposure,\
                filtration_mmAl=filt,\
                grid_ratio=grid_ratio,\
            )\
            compressed_profile = simulate_projection(\
                self.breast_compressed,\
                I0=1.0,\
                sid=sid,\
                sdd=sdd,\
                kVp=kvp,\
                exposure_time=exposure,\
                filtration_mmAl=filt,\
                grid_ratio=grid_ratio,\
            )\
        else:\
            base_profile = baseline\
            compressed_profile = baseline\
\
        def _match_length(arr, target_len):\
            if arr.size == target_len:\
                return arr\
            xp = np.linspace(0, 1, arr.size)\
            xq = np.linspace(0, 1, target_len)\
            return np.interp(xq, xp, arr)\
\
        dist_var = _match_length(dist_var, baseline.size)\
        att_var = _match_length(att_var, baseline.size)\
        angle_var = _match_length(angle_var, baseline.size)\
        base_profile = _match_length(base_profile, baseline.size)\
        compressed_profile = _match_length(compressed_profile, baseline.size)\
        x = np.arange(baseline.size)\
        need_reset_profiles = (\
            not hasattr(self, "profile_lines")\
            or len(self.profile_lines[0].get_xdata()) != baseline.size\
        )\
\
        if need_reset_profiles:\
            self.ax_profile.clear()\
            self.profile_lines = [\
                self.ax_profile.plot(x, baseline, label="Baseline", linewidth=2)[0],\
                self.ax_profile.plot(x, dist_var, label=f"Closer SID \{closer_sid\}", linestyle="--")[0],\
                self.ax_profile.plot(x, att_var, label="Higher \uc0\u956  (denser)", linestyle="-.")[0],\
                self.ax_profile.plot(x, angle_var, label=f"Tilted \{angle_var_deg\}\'b0", linestyle=":")[0],\
                self.ax_profile.plot(x, compressed_profile, label="Compressed phantom", linestyle="-.", color="tab:red")[0],\
            ]\
            self.ax_profile.set_title("Intensity Profile Overlays")\
            self.ax_profile.set_xlabel("Detector Position (pixels)")\
            self.ax_profile.set_ylabel("Intensity")\
            self.ax_profile.grid(alpha=0.2)\
            self.ax_profile.legend()\
            note = (\
                "Notes: smaller SID spreads edges (magnification); higher \uc0\u956  deepens dips; "\
                "tilt shifts edge positions via foreshortening."\
            )\
            self.profile_note = self.ax_profile.text(\
                0.02, 0.95, note,\
                transform=self.ax_profile.transAxes,\
                fontsize=9,\
                va="top",\
                bbox=dict(facecolor="white", alpha=0.7, edgecolor="0.8"),\
            )\
        else:\
            self.profile_lines[0].set_ydata(baseline)\
            self.profile_lines[1].set_ydata(dist_var)\
            self.profile_lines[1].set_label(f"Closer SID \{closer_sid\}")\
            self.profile_lines[2].set_ydata(att_var)\
            self.profile_lines[3].set_ydata(angle_var)\
            self.profile_lines[3].set_label(f"Tilted \{angle_var_deg\}\'b0")\
            self.profile_lines[4].set_ydata(compressed_profile)\
            self.ax_profile.relim()\
            self.ax_profile.autoscale_view()\
            self.ax_profile.legend()\
\
        if use_breast:\
            lesion_mean, lesion_std = roi_mean_std(\
                phantom, phantom_info["lesion_mask"]\
            )\
            bg_mean, bg_std = roi_mean_std(\
                phantom, phantom_info["background_mask"]\
            )\
            contrast = roi_contrast(lesion_mean, bg_mean)\
\
            base_lesion, _ = roi_mean_std(self.breast_base, self.breast_info["lesion_mask"])\
            base_bg, _ = roi_mean_std(self.breast_base, self.breast_info["background_mask"])\
            comp_lesion, _ = roi_mean_std(self.breast_compressed, self.breast_info_compressed["lesion_mask"])\
            comp_bg, _ = roi_mean_std(self.breast_compressed, self.breast_info_compressed["background_mask"])\
            comp_contrast = roi_contrast(comp_lesion, comp_bg)\
            base_contrast = roi_contrast(base_lesion, base_bg)\
\
            self.roi_stats.setText(\
                f"Current ROI \uc0\u956 : lesion \{lesion_mean:.3f\}\'b1\{lesion_std:.3f\}, "\
                f"bg \{bg_mean:.3f\}\'b1\{bg_std:.3f\}, contrast \{contrast:.2f\}\\n"\
                f"Baseline vs compressed contrast: \{base_contrast:.2f\} \uc0\u8594  \{comp_contrast:.2f\}"\
            )\
            self.phantom_info.setText(\
                "Phantom \uc0\u956 : adipose 0.22, gland 0.40, lesion 0.75"\
            )\
        else:\
            self.roi_stats.setText("ROI stats: N/A (toggle breast phantom)")\
            self.phantom_info.setText("Phantom: Shepp-Logan (no labeled ROIs)")\
\
        self.canvas.draw()\
\
\
def main():\
    app = QApplication(sys.argv)\
    gui = XrayGUI()\
    gui.show()\
    sys.exit(app.exec_())\
\
\
if __name__ == "__main__":\
    main()\
\
\
\
\
## generate_figures.py\
\
"""\
Generate required figures and ROI stats for the project deliverables.\
Outputs saved in figs/.\
"""\
import os\
os.environ.setdefault("MPLBACKEND", "Agg")\
import numpy as np\
import matplotlib.pyplot as plt\
from pathlib import Path\
\
from ProjectFunctions.phantom import create_breast_phantom, create_shepp_logan\
from ProjectFunctions.simulate_xray import (\
    simulate_xray_2d,\
    simulate_projection,\
    simulate_projection_angle,\
    simulate_sinogram,\
)\
from ProjectFunctions.utils import roi_mean_std, roi_contrast\
\
FIG_DIR = Path("figs")\
FIG_DIR.mkdir(exist_ok=True)\
\
\
def save_fig(name):\
    """Save current Matplotlib figure to figs/name (png)."""\
    path = FIG_DIR / name\
    plt.savefig(path, bbox_inches="tight", dpi=200)\
    print(f"saved \{path\}")\
\
\
def baseline_and_variations():\
    """Generate baseline radiograph and parameter variation figures; print ROI stats."""\
    phantom, info = create_breast_phantom()\
    params = dict(sid=500, sdd=1000, kVp=35, exposure_time=1.0, filtration_mmAl=2.0, grid_ratio=0.9)\
\
    plt.figure(figsize=(6, 6))\
    plt.imshow(phantom, cmap="magma")\
    plt.title("Phantom \uc0\u956  map (ground truth)")\
    plt.axis("off")\
    save_fig("phantom_ground_truth.png")\
    plt.close()\
\
    img0 = simulate_xray_2d(phantom, angle_deg=0, **params)\
    plt.figure(figsize=(6, 6))\
    plt.imshow(img0, cmap="gray", vmin=0, vmax=0.7)\
    plt.title("Baseline Radiograph (0\'b0)")\
    plt.axis("off")\
    save_fig("baseline_radiograph.png")\
    plt.close()\
\
    img_sid_near = simulate_xray_2d(phantom, angle_deg=0, sid=350, sdd=1000, **\{k: v for k, v in params.items() if k not in ["sid", "sdd"]\})\
    img_sid_far = simulate_xray_2d(phantom, angle_deg=0, sid=700, sdd=1000, **\{k: v for k, v in params.items() if k not in ["sid", "sdd"]\})\
    plt.figure(figsize=(12, 4))\
    for i, (im, title) in enumerate([\
        (img0, "Baseline (SID 500)"),\
        (img_sid_near, "Closer SID 350"),\
        (img_sid_far, "Farther SID 700"),\
    ]):\
        plt.subplot(1, 3, i + 1)\
        plt.imshow(im, cmap="gray", vmin=0, vmax=0.7)\
        plt.title(title)\
        plt.axis("off")\
    save_fig("distance_variation.png")\
    plt.close()\
\
    dense_phantom = phantom * 1.2\
    img_dense = simulate_xray_2d(dense_phantom, angle_deg=0, **params)\
    plt.figure(figsize=(8, 4))\
    for i, (im, title) in enumerate([\
        (img0, "Baseline \uc0\u956 "),\
        (img_dense, "Higher \uc0\u956  (denser)"),\
    ]):\
        plt.subplot(1, 2, i + 1)\
        plt.imshow(im, cmap="gray", vmin=0, vmax=0.7)\
        plt.title(title)\
        plt.axis("off")\
    save_fig("mu_variation.png")\
    plt.close()\
\
    angles = [0, 15, 30]\
    plt.figure(figsize=(12, 4))\
    for i, a in enumerate(angles):\
        img = simulate_xray_2d(phantom, angle_deg=a, **params)\
        plt.subplot(1, 3, i + 1)\
        plt.imshow(img, cmap="gray", vmin=0, vmax=0.7)\
        plt.title(f"Angle \{a\}\'b0")\
        plt.axis("off")\
    save_fig("angle_variation.png")\
    plt.close()\
\
    baseline_profile = simulate_projection(phantom, I0=1.0, **params)\
    dist_near = simulate_projection(phantom, I0=1.0, sid=350, sdd=1000, **\{k: v for k, v in params.items() if k not in ["sid", "sdd"]\})\
    dense_profile = simulate_projection(dense_phantom, I0=1.0, **params)\
    angle_profile, _ = simulate_projection_angle(phantom, angle_deg=20, I0=1.0, **params)\
\
    x = np.arange(baseline_profile.size)\
    plt.figure(figsize=(8, 4))\
    plt.plot(x, baseline_profile, label="Baseline", linewidth=2)\
    plt.plot(x, dist_near, label="Closer SID 350", linestyle="--")\
    plt.plot(x, dense_profile, label="Higher \uc0\u956 ", linestyle="-.")\
    plt.plot(x, angle_profile, label="Angle 20\'b0", linestyle=":")\
    plt.xlabel("Detector position (px)")\
    plt.ylabel("Intensity")\
    plt.title("Profile overlays (distance, \uc0\u956 , angle)")\
    plt.legend()\
    plt.grid(alpha=0.2)\
    save_fig("profile_overlays.png")\
    plt.close()\
\
    phantom_comp, info_comp = create_breast_phantom(compression=True)\
    profile_comp = simulate_projection(phantom_comp, I0=1.0, **params)\
    plt.figure(figsize=(8, 4))\
    plt.plot(x, baseline_profile, label="Baseline", linewidth=2)\
    plt.plot(x, profile_comp, label="Compressed", linestyle="--")\
    plt.xlabel("Detector position (px)")\
    plt.ylabel("Intensity")\
    plt.title("Profile: baseline vs compressed")\
    plt.legend()\
    plt.grid(alpha=0.2)\
    save_fig("profile_compressed.png")\
    plt.close()\
\
    def roi_stats(p, info_local, label):\
        lesion_mean, lesion_std = roi_mean_std(p, info_local["lesion_mask"])\
        bg_mean, bg_std = roi_mean_std(p, info_local["background_mask"])\
        contrast = roi_contrast(lesion_mean, bg_mean)\
        print(f"\{label\}: lesion \{lesion_mean:.3f\}\'b1\{lesion_std:.3f\}, bg \{bg_mean:.3f\}\'b1\{bg_std:.3f\}, contrast \{contrast:.2f\}")\
        return lesion_mean, lesion_std, bg_mean, bg_std, contrast\
\
    roi_stats(phantom, info, "Baseline phantom \uc0\u956 ")\
    roi_stats(phantom_comp, info_comp, "Compressed phantom \uc0\u956 ")\
\
\
def sinogram_and_schematic():\
    """Generate sinogram and phantom schematic figures."""\
    phantom, _ = create_breast_phantom()\
    angles = np.linspace(0, 180, 181)\
    sino, _ = simulate_sinogram(phantom, max_angle=180, sid=500, sdd=1000, kVp=35, exposure=1.0, filtration=2.0, grid_ratio=0.9)\
    plt.figure(figsize=(8, 4))\
    plt.imshow(sino, cmap="gray", aspect="auto")\
    plt.xlabel("Detector position")\
    plt.ylabel("Angle (deg)")\
    plt.title("Sinogram (0-180\'b0)")\
    save_fig("sinogram.png")\
    plt.close()\
\
    plt.figure(figsize=(6, 6))\
    plt.imshow(phantom, cmap="magma")\
    plt.title("Phantom \uc0\u956  map (ground truth)")\
    plt.axis("off")\
    save_fig("phantom_ground_truth.png")\
    plt.close()\
\
\
def main():\
    """Entry point: build all figures."""\
    baseline_and_variations()\
    sinogram_and_schematic()\
\
\
if __name__ == "__main__":\
    main()\
\
\
\
\
## main.py\
\
import numpy as np\
import matplotlib.pyplot as plt\
\
from ProjectFunctions.phantom import create_shepp_logan\
from ProjectFunctions.simulate_xray import (\
    simulate_projection,\
    simulate_projection_angle,\
    simulate_2d_projection\
)\
\
\
def test_basic(phantom):\
    """Display phantom \uc0\u956 -map and baseline 1D projection at 0\'b0."""\
    plt.figure()\
    plt.imshow(phantom, cmap='gray')\
    plt.title("Phantom (Ground Truth)")\
    plt.colorbar(label="\uc0\u956 ")\
    plt.show()\
\
    projection = simulate_projection(\
        phantom,\
        I0=1.0,\
        sid=500,\
        sdd=1000,\
        kVp=30,\
        exposure_time=1.0,\
        filtration_mmAl=2.0,\
    )\
\
    plt.figure()\
    plt.plot(projection)\
    plt.title("1D X-ray Projection at 0\'b0")\
    plt.xlabel("Detector Position")\
    plt.ylabel("Intensity")\
    plt.show()\
\
\
def plot_profile_overlays(phantom):\
    """Overlay baseline profile with distance, attenuation, and angle variations."""\
    base_sid = 500\
    base_sdd = 1000\
    base_kvp = 30\
    base_exposure = 1.0\
    base_filt = 2.0\
\
    x = np.arange(phantom.shape[1])\
    baseline = simulate_projection(\
        phantom,\
        I0=1.0,\
        sid=base_sid,\
        sdd=base_sdd,\
        kVp=base_kvp,\
        exposure_time=base_exposure,\
        filtration_mmAl=base_filt,\
    )\
\
    closer_sid = 350\
    closer_sdd = 1000\
    dist_var = simulate_projection(\
        phantom,\
        I0=1.0,\
        sid=closer_sid,\
        sdd=closer_sdd,\
        kVp=base_kvp,\
        exposure_time=base_exposure,\
        filtration_mmAl=base_filt,\
    )\
\
    dense_phantom = phantom * 1.25\
    att_var = simulate_projection(\
        dense_phantom,\
        I0=1.0,\
        sid=base_sid,\
        sdd=base_sdd,\
        kVp=base_kvp,\
        exposure_time=base_exposure,\
        filtration_mmAl=base_filt,\
    )\
\
    angle_deg = 20\
    angle_var, _ = simulate_projection_angle(\
        phantom,\
        angle_deg,\
        I0=1.0,\
        sid=base_sid,\
        sdd=base_sdd,\
        kVp=base_kvp,\
        exposure_time=base_exposure,\
        filtration_mmAl=base_filt,\
    )\
\
    plt.figure(figsize=(10, 5))\
    plt.plot(x, baseline, label="Baseline (0\'b0, SID 500/SDD 1000)", linewidth=2)\
    plt.plot(x, dist_var, label="Closer source (SID 350 \uc0\u8594  more magnification)", linestyle="--")\
    plt.plot(x, att_var, label="Higher \uc0\u956  (denser material)", linestyle="-.")\
    plt.plot(x, angle_var, label=f"Tilted object (\{angle_deg\}\'b0)", linestyle=":")\
\
    plt.title("Intensity Profile Overlays (Signal vs Position)")\
    plt.xlabel("Detector Position (pixels)")\
    plt.ylabel("Intensity")\
    plt.legend()\
    plt.grid(alpha=0.2)\
\
    note = (\
        "Notes:\\n"\
        "\'95 Smaller SID => larger magnification, edges spread outward.\\n"\
        "\'95 Higher \uc0\u956  deepens valleys/peaks (stronger attenuation).\\n"\
        "\'95 Tilting shifts edge positions due to foreshortening."\
    )\
    plt.gcf().text(0.62, 0.4, note, fontsize=9,\
                   bbox=dict(facecolor="white", alpha=0.7, edgecolor="0.8"))\
    plt.tight_layout()\
    plt.show()\
\
\
def test_angles(phantom):\
    """Plot 1D projection profiles for several angles."""\
    angles = [0, 15, 30, 45, 60]\
    plt.figure(figsize=(10, 5))\
\
    for a in angles:\
        I, _ = simulate_projection_angle(\
            phantom,\
            a,\
            I0=1.0,\
            sid=500,\
            sdd=1000,\
            kVp=30,\
            exposure_time=1.0,\
            filtration_mmAl=2.0\
        )\
        plt.plot(I, label=f"\{a\}\'b0")\
\
    plt.title("Projection Profiles at Different Angles")\
    plt.xlabel("Detector Position")\
    plt.ylabel("Intensity")\
    plt.legend()\
    plt.show()\
\
\
def test_sinogram(phantom):\
    """Compute and display simple sinogram from phantom across 0-180\'b0."""\
    angles = np.linspace(0, 180, 181)\
    sinogram = simulate_2d_projection(\
        phantom,\
        angles,\
    )\
\
    plt.figure()\
    plt.imshow(sinogram, cmap='gray', aspect='auto')\
    plt.title("2D Projection (Sinogram)")\
    plt.xlabel("Detector Position")\
    plt.ylabel("Angle (degrees)")\
    plt.colorbar()\
    plt.show()\
\
\
def main():\
    """Run demo plots on Shepp-Logan phantom."""\
    phantom = create_shepp_logan()\
\
    test_basic(phantom)\
    plot_profile_overlays(phantom)\
    test_angles(phantom)\
    test_sinogram(phantom)\
\
\
if __name__ == "__main__":\
    main()\
\
\
\
\
## ProjectFunctions/phantom.py\
\
from skimage.data import shepp_logan_phantom\
from skimage.transform import resize\
import numpy as np\
\
\
def create_shepp_logan(nx=256, ny=256):\
    """Return resized Shepp-Logan phantom with boosted \uc0\u956 ."""\
    phantom = shepp_logan_phantom()\
    phantom = resize(phantom, (nx, ny), anti_aliasing=True)\
    phantom = 0.1 + phantom * 1.5\
    return phantom\
\
\
def create_breast_phantom(\
    nx=256,\
    ny=256,\
    lesion_radius=25,\
    compression=False,\
    compression_factor=0.65,\
):\
    """\
    Build 2D breast phantom with skin, pectoral wedge, glandular crescent, lesion, calc spots, benign ellipse.\
    Returns (phantom, info) where info contains ROI masks (lesion/background) and \uc0\u956  values.\
    """\
    adipose_mu = 0.22\
    gland_mu = 0.40\
    lesion_mu = 0.75\
    micro_mu = 0.55\
    muscle_mu = 0.50\
    skin_mu = 0.80\
\
    x = np.linspace(-1, 1, nx)\
    y = np.linspace(-1, 1, ny)\
    xx, yy = np.meshgrid(x, y, indexing="ij")\
\
    breast_mask = (xx**2) / (0.9**2) + (yy**2) / (1.0**2) <= 1.0\
    phantom = np.full((nx, ny), adipose_mu)\
    phantom[~breast_mask] = 0.0\
\
    thickness = np.exp(-3.0 * (xx**2 + yy**2))\
    phantom *= 0.8 + 0.2 * thickness\
\
    skin_rim = (np.abs((xx**2) / (0.92**2) + (yy**2) / (1.02**2) - 1.0) < 0.03)\
    phantom[skin_rim] = skin_mu\
\
    pec_mask = (xx < -0.55) & (yy > -0.2) & (yy < 0.9) & ((yy + 0.9) > (xx + 0.2))\
    phantom[pec_mask] = muscle_mu\
\
    gland_mask = ((xx + 0.15) ** 2) / (0.55**2) + (yy**2) / (0.6**2) <= 1.0\
    gland_mask |= ((xx + 0.05) ** 2) / (0.45**2) + ((yy + 0.15) ** 2) / (0.5**2) <= 1.0\
    phantom[gland_mask & breast_mask] = gland_mu\
\
    cx = nx // 2\
    cy = ny // 2\
    rr = lesion_radius\
    lesion_mask = (\
        (np.arange(nx)[:, None] - cx) ** 2 + (np.arange(ny)[None, :] - cy - 25) ** 2\
    ) <= rr**2\
    phantom[lesion_mask] = lesion_mu\
\
    rng = np.random.default_rng(42)\
    num_spots = 7\
    spot_centers = rng.normal(loc=[-0.1, 0.1], scale=0.18, size=(num_spots, 2))\
    for sx, sy in spot_centers:\
        rad = rng.uniform(0.015, 0.04)\
        spot_mask = (xx - sx) ** 2 + (yy - sy) ** 2 <= rad**2\
        phantom[spot_mask & breast_mask] = micro_mu\
\
    benign_mask = ((xx + 0.35) ** 2) / (0.12**2) + ((yy - 0.25) ** 2) / (0.08**2) <= 1.0\
    phantom[benign_mask & breast_mask] = (gland_mu + micro_mu) * 0.5\
\
    info = \{\
        "adipose_mu": adipose_mu,\
        "gland_mu": gland_mu,\
        "lesion_mu": lesion_mu,\
        "lesion_mask": lesion_mask,\
        "background_mask": breast_mask & (~lesion_mask),\
    \}\
\
    if compression:\
        phantom, info = _compress_phantom(phantom, info, compression_factor)\
\
    return phantom, info\
\
\
def _compress_phantom(phantom, info, factor):\
    """Compress along superior-inferior axis by factor, pad to original size, and adjust masks."""\
    nx, ny = phantom.shape\
    comp_nx = max(1, int(nx * factor))\
    compressed = resize(\
        phantom,\
        (comp_nx, ny),\
        anti_aliasing=True,\
        preserve_range=True,\
    )\
\
    pad_top = (nx - comp_nx) // 2\
    pad_bottom = nx - comp_nx - pad_top\
    compressed = np.pad(compressed, ((pad_top, pad_bottom), (0, 0)), mode="edge")\
\
    def compress_mask(mask):\
        cm = resize(\
            mask.astype(float),\
            (comp_nx, ny),\
            anti_aliasing=False,\
            preserve_range=True,\
        )\
        cm = cm > 0.5\
        cm = np.pad(cm, ((pad_top, pad_bottom), (0, 0)), mode="edge")\
        return cm\
\
    comp_info = info.copy()\
    comp_info["lesion_mask"] = compress_mask(info["lesion_mask"])\
    comp_info["background_mask"] = compress_mask(info["background_mask"])\
    comp_info["compressed"] = True\
    comp_info["compression_factor"] = factor\
    comp_info["adipose_mu"] = info["adipose_mu"]\
    comp_info["gland_mu"] = info["gland_mu"]\
    comp_info["lesion_mu"] = info["lesion_mu"]\
\
    return compressed, comp_info\
\
\
\
\
## ProjectFunctions/simulate_xray.py\
\
import numpy as np\
from skimage.transform import rotate, rescale\
\
def simulate_xray_2d(\
        phantom,\
        angle_deg,\
        I0=1.0,\
        sid=500.0,\
        sdd=1000.0,\
        kVp=30.0,\
        exposure_time=1.0,\
        filtration_mmAl=0.0,\
        grid_ratio=1.0,\
    ):\
    """\
    Compute 2D radiograph: rotate phantom, magnify (sdd/sid), apply Beer\'96Lambert with energy,\
    filtration, exposure, and grid scaling. Params: phantom (2D \uc0\u956 ), angle_deg, I0, sid, sdd,\
    kVp, exposure_time, filtration_mmAl, grid_ratio.\
    """\
    rotated = rotate(phantom, angle=angle_deg, resize=False, mode="edge")\
    nx, ny = rotated.shape\
\
    M = sdd / sid\
    mag = rescale(rotated, M, mode='edge', preserve_range=True, anti_aliasing=False)\
\
    sx, sy = mag.shape\
    out = np.zeros_like(rotated)\
    x_start = max((sx - nx) // 2, 0)\
    y_start = max((sy - ny) // 2, 0)\
    x_end = x_start + min(nx, sx)\
    y_end = y_start + min(ny, sy)\
    ox = max((nx - sx) // 2, 0)\
    oy = max((ny - sy) // 2, 0)\
    out[ox:ox + (x_end - x_start), oy:oy + (y_end - y_start)] = mag[x_start:x_end, y_start:y_end]\
    mag = out\
\
    raw_path = np.cumsum(mag, axis=1)\
    path_integral = raw_path / (ny * 0.05)\
\
    energy_factor = (60.0 / kVp)\
    path_integral *= energy_factor\
\
    mu_al_ref = 0.12\
    mu_al = mu_al_ref * (30.0 / kVp)\
    path_integral += filtration_mmAl * mu_al\
\
    I = I0 * np.exp(-path_integral)\
\
    I *= (exposure_time * 1.2)\
    I = _apply_grid(I, grid_ratio)\
\
    I = np.clip(I, 0.0, 1.0)\
\
    return I\
\
\
\
\
def _apply_magnification(image, sid, sdd):\
    """Magnify by M=sdd/sid using rescale + center crop/pad to original size."""\
    M = sdd / sid\
    if np.isclose(M, 1.0):\
        return image\
\
    nx, ny = image.shape\
\
    scaled = rescale(\
        image,\
        scale=M,\
        mode='edge',\
        anti_aliasing=False,\
        preserve_range=True,\
    )\
\
    sx, sy = scaled.shape\
    out = np.zeros_like(image)\
\
    x_start = max((sx - nx) // 2, 0)\
    y_start = max((sy - ny) // 2, 0)\
    x_end = x_start + min(nx, sx)\
    y_end = y_start + min(ny, sy)\
\
    ox_start = max((nx - sx) // 2, 0)\
    oy_start = max((ny - sy) // 2, 0)\
    ox_end = ox_start + (x_end - x_start)\
    oy_end = oy_start + (y_end - y_start)\
\
    out[ox_start:ox_end, oy_start:oy_end] = scaled[x_start:x_end, y_start:y_end]\
\
    return out\
\
def _apply_energy_scaling(path_integral, kVp, ref_kVp=30.0):\
    """Scale attenuation by ref_kVp/kVp (higher kVp => lower effective \uc0\u956 )."""\
    return path_integral * (ref_kVp / kVp)\
\
\
def _apply_filtration(path_integral, filtration_mmAl, kVp):\
    """Add filtration term proportional to mm Al and inverse kVp."""\
    mu_al_ref = 0.15\
    mu_al = mu_al_ref * (30.0 / kVp)\
    extra = filtration_mmAl * mu_al\
    return path_integral + extra\
\
\
def _apply_exposure(I, exposure_time, ref_time=1.0):\
    """Scale intensity by exposure_time/ref_time."""\
    return I * (exposure_time / ref_time)\
\
def _apply_grid(I, grid_ratio=1.0):\
    """Apply grid attenuation multiplier (<=1)."""\
    return I * grid_ratio\
\
\
def simulate_projection(phantom, I0=1.0,\
                        sid=500.0, sdd=1000.0,\
                        kVp=30.0,\
                        exposure_time=1.0,\
                        filtration_mmAl=0.0,\
                        grid_ratio=1.0):\
    """\
    1D vertical projection with magnification and Beer\'96Lambert physics.\
    Params: phantom, I0, sid, sdd, kVp, exposure_time, filtration_mmAl, grid_ratio.\
    """\
    mag_phantom = _apply_magnification(phantom, sid, sdd)\
\
    path_integral = np.sum(mag_phantom, axis=0)\
\
    path_integral = _apply_energy_scaling(path_integral, kVp)\
    path_integral = _apply_filtration(path_integral, filtration_mmAl, kVp)\
\
    I = I0 * np.exp(-path_integral)\
\
    I = _apply_exposure(I, exposure_time)\
    I = _apply_grid(I, grid_ratio)\
\
    return I\
\
\
def simulate_projection_angle(phantom, angle_deg, I0=1.0,\
                              sid=500.0, sdd=1000.0,\
                              kVp=30.0,\
                              exposure_time=1.0,\
                              filtration_mmAl=0.0,\
                              grid_ratio=1.0):\
    """\
    Angled projection with rotation, magnification, energy/filtration, exposure, grid.\
    Params: phantom, angle_deg, I0, sid, sdd, kVp, exposure_time, filtration_mmAl, grid_ratio.\
    """\
    rotated = rotate(phantom, angle=angle_deg, resize=False, mode='edge')\
    rotated_mag = _apply_magnification(rotated, sid, sdd)\
\
    path_integral = np.sum(rotated_mag, axis=0)\
\
    path_integral = _apply_energy_scaling(path_integral, kVp)\
    path_integral = _apply_filtration(path_integral, filtration_mmAl, kVp)\
\
    I = I0 * np.exp(-path_integral)\
    I = _apply_exposure(I, exposure_time)\
    I = _apply_grid(I, grid_ratio)\
\
    return I, rotated_mag\
\
\
def simulate_2d_projection(phantom, angles_deg, I0=1.0):\
    """\
    Compute a 2D Radon sinogram:\
    Each row = projection at one angle\
    Each column = detector pixel\
    Params: phantom, angles_deg (iterable), I0 incident intensity.\
    """\
    sinogram = []\
\
    for angle in angles_deg:\
        rotated = rotate(phantom, angle=angle, resize=False, mode='edge')\
\
        projection = np.sum(rotated, axis=0)\
\
        I = I0 * np.exp(-projection)\
\
        sinogram.append(I)\
\
    return np.array(sinogram)\
\
import numpy as np\
from skimage.transform import rotate\
\
def simulate_sinogram(\
        phantom,\
        max_angle_deg=180.0,\
        angle_step_deg=1.0,\
        I0=1.0,\
        sid=500.0,\
        sdd=1000.0,\
        kVp=30.0,\
        exposure_time=1.0,\
        filtration_mmAl=0.0,\
        grid_ratio=1.0,\
    ):\
    """\
    Compute sinogram with magnification, energy/filtration, exposure, grid.\
    Params: phantom, max_angle_deg, angle_step_deg, I0, sid, sdd, kVp, exposure_time, filtration_mmAl, grid_ratio.\
    """\
\
    mag_phantom = _apply_magnification(phantom, sid, sdd)\
\
    if max_angle_deg <= 0:\
        max_angle_deg = 1.0\
    angles_deg = np.arange(0.0, max_angle_deg + 1e-6, angle_step_deg)\
\
    sinogram_rows = []\
\
    thickness_scale = 40.0\
\
    for ang in angles_deg:\
        rotated = rotate(mag_phantom, angle=ang, resize=False, mode="edge")\
\
        path_integral = np.sum(rotated, axis=0) / thickness_scale\
\
        path_integral = _apply_energy_scaling(path_integral, kVp)\
        path_integral = _apply_filtration(path_integral, filtration_mmAl, kVp)\
\
        I = I0 * np.exp(-path_integral)\
\
        I = _apply_exposure(I, exposure_time)\
        I = _apply_grid(I, grid_ratio)\
\
        sinogram_rows.append(I)\
\
    sinogram = np.array(sinogram_rows)\
\
    sinogram = np.clip(sinogram, 0.0, 1.0)\
\
    return sinogram, angles_deg\
\
\
from skimage.transform import radon\
\
def simulate_projection_single(phantom, angle_deg, sid, sdd, kVp, exposure, filtration, grid_ratio=1.0):\
    """Single-angle Radon projection expanded to 2D for display. Params: phantom, angle_deg, sid, sdd, kVp, exposure, filtration, grid_ratio."""\
    mag = _apply_magnification(phantom, sid, sdd)\
\
    theta = [angle_deg]\
    sinogram = radon(mag, theta=theta, circle=False)\
\
    proj = sinogram[:, 0]\
\
    proj = _apply_energy_scaling(proj, kVp)\
    proj = _apply_filtration(proj, filtration, kVp)\
    I = np.exp(-proj)\
    I = _apply_exposure(I, exposure)\
    I = _apply_grid(I, grid_ratio)\
\
    img = np.tile(I, (phantom.shape[0], 1))\
    return np.clip(img, 0, 1)\
\
def simulate_sinogram(phantom, max_angle, sid, sdd, kVp, exposure, filtration, grid_ratio=1.0):\
    """Legacy sinogram builder using Radon on magnified phantom. Params: phantom, max_angle, sid, sdd, kVp, exposure, filtration, grid_ratio."""\
    mag = _apply_magnification(phantom, sid, sdd)\
    angles = np.arange(0, max_angle + 1, 1)\
    sino = radon(mag, theta=angles, circle=False)\
\
    sino = _apply_energy_scaling(sino, kVp)\
    sino = _apply_filtration(sino, filtration, kVp)\
    sino = np.exp(-sino)\
    sino = _apply_exposure(sino, exposure)\
    sino = _apply_grid(sino, grid_ratio=grid_ratio)\
\
    return np.clip(sino, 0, 1), angles\
\
\
\
\
## ProjectFunctions/utils.py\
\
import numpy as np\
\
def rotate_image_nn(image: np.ndarray, theta_deg: float) -> np.ndarray:\
    """Rotate 2D array by theta_deg (deg) about center using nearest neighbor."""\
    if theta_deg % 360 == 0:\
        return image.copy()\
\
    theta = np.deg2rad(theta_deg)\
    cos_t = np.cos(theta)\
    sin_t = np.sin(theta)\
\
    nx, ny = image.shape\
    cx = (nx - 1) / 2.0\
    cy = (ny - 1) / 2.0\
\
    x_out, y_out = np.indices((nx, ny))\
    x_out_c = x_out - cx\
    y_out_c = y_out - cy\
\
    x_in_c = cos_t * x_out_c + sin_t * y_out_c\
    y_in_c = -sin_t * x_out_c + cos_t * y_out_c\
\
    x_in = np.round(x_in_c + cx).astype(int)\
    y_in = np.round(y_in_c + cy).astype(int)\
\
    rotated = np.zeros_like(image)\
\
    inside = (\
        (x_in >= 0) & (x_in < nx) &\
        (y_in >= 0) & (y_in < ny)\
    )\
\
    rotated[inside] = image[x_in[inside], y_in[inside]]\
    return rotated\
\
\
def apply_magnification(phantom: np.ndarray,\
                        sid: float,\
                        sdd: float) -> np.ndarray:\
    """Nearest-neighbor magnification by factor M=SDD/SID, preserving output size."""\
    M = sdd / sid\
    if np.isclose(M, 1.0):\
        return phantom.copy()\
\
    nx, ny = phantom.shape\
    cx = (nx - 1) / 2.0\
    cy = (ny - 1) / 2.0\
\
    x_out, y_out = np.indices((nx, ny))\
    x_out_c = x_out - cx\
    y_out_c = y_out - cy\
\
    x_in_c = x_out_c / M\
    y_in_c = y_out_c / M\
\
    x_in = np.round(x_in_c + cx).astype(int)\
    y_in = np.round(y_in_c + cy).astype(int)\
\
    mag = np.zeros_like(phantom)\
    inside = (\
        (x_in >= 0) & (x_in < nx) &\
        (y_in >= 0) & (y_in < ny)\
    )\
    mag[inside] = phantom[x_in[inside], y_in[inside]]\
    return mag\
\
\
def apply_energy_scaling(path_integral: np.ndarray,\
                         energy_keV: float,\
                         ref_energy_keV: float = 30.0) -> np.ndarray:\
    """Scale attenuation by ref_energy_keV/energy_keV to mimic higher kVp reduction."""\
    scale = ref_energy_keV / energy_keV\
    return path_integral * scale\
\
\
def apply_filtration(path_integral: np.ndarray,\
                     filtration_mmAl: float,\
                     energy_keV: float) -> np.ndarray:\
    """Add equivalent aluminum thickness term; crude beam hardening surrogate."""\
    mu_al_ref = 0.15\
    mu_al = mu_al_ref * (30.0 / energy_keV)\
\
    extra = filtration_mmAl * mu_al\
    return path_integral + extra\
\
\
def apply_exposure(I: np.ndarray,\
                   exposure_time: float,\
                   ref_time: float = 1.0) -> np.ndarray:\
    """Scale intensity linearly by exposure_time/ref_time."""\
    return I * (exposure_time / ref_time)\
\
\
def roi_mean_std(image: np.ndarray, mask: np.ndarray):\
    """Return mean/std within boolean mask; nan if mask empty."""\
    masked = image[mask]\
    if masked.size == 0:\
        return float("nan"), float("nan")\
    return float(masked.mean()), float(masked.std())\
\
\
def roi_contrast(mean_lesion: float, mean_background: float):\
    """Absolute difference normalized by background mean; nan on invalid input."""\
    if np.isnan(mean_lesion) or np.isnan(mean_background) or np.isclose(mean_background, 0):\
        return float("nan")\
    return abs(mean_lesion - mean_background) / mean_background\
\
\
\
}